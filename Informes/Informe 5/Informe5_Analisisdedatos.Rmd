---
title: "Informe 5"
subtitle: "Datos de Expresión génica y proteica."
author: "Carmen Lebrero Cia"
date: "19/10/2020"
output:
  html_document:
    df_print: paged
    toc: true
    toc_depth: 4
  pdf_document: 
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
if (!requireNamespace("BiocManager", quietly=TRUE))
    install.packages("BiocManager")
BiocManager::install("TCGAbiolinks")
library(TCGAbiolinks)
library(dplyr)
library(SummarizedExperiment)
library(DT)
```



```{r include=FALSE}
setwd("D:/datos")
query1 <- GDCquery(project = "TCGA-KIRC",
                  data.category = "Protein expression",
                  legacy = TRUE)
GDCdownload(query1)
ExprProtKIRC <- GDCprepare(query1)
setwd("D:/datos")
query1 <- GDCquery(project = "TCGA-KIRC",
                  data.category = "Protein expression",
                  legacy = TRUE)
GDCdownload(query1)
ExprProtKIRC <- GDCprepare(query1)

query5C <- GDCquery(project = "TCGA-KIRC",
                  data.category = "Gene expression",
                  data.type = "Gene expression quantification",
                  experimental.strategy = "RNA-Seq",
                  file.type = "results",
                  legacy = TRUE)
GDCdownload(query5C)
ExpGenKIRC3 <- GDCprepare(query5C)


setwd("D:/datos")
query8B <- GDCquery(project = "TCGA-KIRC",
                  data.category = "Clinical", data.type = "Clinical Supplement",
                  legacy = TRUE)
GDCdownload(query8B)
ClinicKIRC2 <- GDCprepare_clinic(query8B, clinical.info = "patient")
```


# Archivos de datos clínicos

Si utilizamos la función ```str()``` sobre ```ClinicKIRC2``` (datos clínicos de TCGA-KIRC) observamos que se trata de un archivo Dataframe con 537 observaciones y 66 variables.

```{r}
str(ClinicKIRC2)
```

De entre todas las variables las más interesantes parecen ser ```bcr_patient_barcode```, ```vital_status``` o ```stage_event_pathologic_stage```. Vamos a encontrar los índices de cada variable en el dataframe y podemos hacer un dataframe más pequeño.

```{r}
grep("bcr_patient_barcode", colnames(ClinicKIRC2))
grep("vital_status", colnames(ClinicKIRC2))
grep("stage_event_pathologic_stage", colnames(ClinicKIRC2))
```

```{r}
ClinicS <- ClinicKIRC2[,c(1,7,59)]
head(ClinicS)
```

Vamos a ver si existen missing values con ```is.na()```.

```{r}
sum(is.na(ClinicS))
```

Observamos que no tenemos ningún NA en este Dataset, por lo que tenemos datos de nuestra variable de interés para los 537 pacientes del estudio TCGA-KIRC.

Podemos sacar más información a partir de estas variables. Por ejemplo, podemos observar con una gráfica según la variable de estadío patológico que la mayoría de nuestras pertenecen al estadío I, seguido de las muestras en el estadío III, IV, II y 0.

```{r}
plot(ClinicKIRC2$stage_event_pathologic_stage)
```

Podemos obtener el número exacto de pacientes con la función ```summmary()```.

```{r}
summary(ClinicKIRC2$stage_event_pathologic_stage)
```

Esta clasificación por estadíos se refiere a lo siguiente a un método de agrupación de los pacientes según una serie de características de los tumores como la localización y el tamaño del tumor (T), si se observan ganglios linfáticos cerca (N) o si hay metástasis (M).

* **Estadío 0**. Describe cáncer "in situ" que están localizados en el lugar de origen y no se han esparcido a tejidos cercanos. Son tumores fácilmente curables que se pueden quitar con una cirugía.

* **Estadío 1**. Se trata de un tumor pequeño que no se ha extendido de forma muy profunda a tejidos colindantes ni a los ganglios linfáticos. A veces se le denomina cáncer temprano.

* **Estadíos II y III**. Estos dos estadíos indican tumores más grandes que se han extendido de forma más profunda a tejidos y que pueden haber llegado a los ganglios linfáticos pero no a otros órganos.

* **Estadío IV**. Este estadío significa que el cáncer se ha extendido a otros órganos. También conocido como cáncer metastásico avanzado.

También podemos obtener información acerca de los fallecimientos de nuestra muestra. Y observamos que 372 siguen vivos y 162 han fallecido. Volvemos  a ver 3 muestras que no están catalogadas en ninguno de estos dos grupos, debemos ver si esas muestras, aunque hayamos hecho anteriormente la búsqueda de missing values, no contienen información.


```{r}
plot(ClinicKIRC2$vital_status)
```

```{r}
summary(ClinicKIRC2$vital_status)
```

Otro análisis interesante sería saber cuántos fallecidos hay según el estadío del tumor.

```{r}
plot(vital_status ~ stage_event_pathologic_stage, data = ClinicKIRC2)
```

**Fase I (n=269)**

Fallecidos

```{r}
length(subset(ClinicKIRC2$patient_id , ClinicKIRC2$vital_status == "Dead" & ClinicKIRC2$stage_event_pathologic_stage == "Stage I"))
```

Vivos


```{r}
length(subset(ClinicKIRC2$patient_id , ClinicKIRC2$vital_status == "Alive" & ClinicKIRC2$stage_event_pathologic_stage == "Stage I"))

```

**Fase II (n=57)**

Fallecidos

```{r}
length(subset(ClinicKIRC2$patient_id , ClinicKIRC2$vital_status == "Dead" & ClinicKIRC2$stage_event_pathologic_stage == "Stage II"))
```

Vivos


```{r}
length(subset(ClinicKIRC2$patient_id , ClinicKIRC2$vital_status == "Alive" & ClinicKIRC2$stage_event_pathologic_stage == "Stage II"))

```

**Fase III (n=125)**

Fallecidos

```{r}
length(subset(ClinicKIRC2$patient_id , ClinicKIRC2$vital_status == "Dead" & ClinicKIRC2$stage_event_pathologic_stage == "Stage III"))
```

Vivos


```{r}
length(subset(ClinicKIRC2$patient_id , ClinicKIRC2$vital_status == "Alive" & ClinicKIRC2$stage_event_pathologic_stage == "Stage III"))

```

**Fase IV (n=83)**

Fallecidos

```{r}
length(subset(ClinicKIRC2$patient_id , ClinicKIRC2$vital_status == "Dead" & ClinicKIRC2$stage_event_pathologic_stage == "Stage IV"))
```

Vivos


```{r}
length(subset(ClinicKIRC2$patient_id , ClinicKIRC2$vital_status == "Alive" & ClinicKIRC2$stage_event_pathologic_stage == "Stage IV"))

```

Vamos a buscar esos pacientes que no tienen vital_status asignado:

```{r}
subset(ClinicKIRC2$bcr_patient_barcode , ClinicKIRC2$vital_status != "Dead" & ClinicKIRC2$vital_status != "Alive")
```

Y ver si estos tres son los mismos que no tienen asignada la fase del tumor:

```{r}
subset(ClinicKIRC2$bcr_patient_barcode , ClinicKIRC2$stage_event_pathologic_stage != "Stage I" & ClinicKIRC2$stage_event_pathologic_stage != "Stage II" & ClinicKIRC2$stage_event_pathologic_stage != "Stage III" & ClinicKIRC2$stage_event_pathologic_stage != "Stage IV")
```

No son los mismos pacientes los que no tienen etiqueta para vital_status y para la Fase del cancer. Creamos dos Datasets. ```ClinicSVital``` sin los tres pacientes que no tienen etiqueta para Vital_status y ```ClinicSStage``` sin los pacientes que no tienen etiqueta para Stage. Además se crearán dos cadenas de caracteres con los barcodes de cada Dataframe.

```{r}
ClinicSVital <- subset(ClinicS, ClinicS$bcr_patient_barcode != "TCGA-BP-4326" & ClinicS$bcr_patient_barcode != "TCGA-BP-4329" & ClinicS$bcr_patient_barcode != "TCGA-BP-4334")
```

```{r}
ClinicSStage <- subset(ClinicS, ClinicS$bcr_patient_barcode != "TCGA-B4-5838" & ClinicS$bcr_patient_barcode != "TCGA-BP-4798" & ClinicS$bcr_patient_barcode != "TCGA-MM-A563")
```

Si elegimos como variable a modelar ```vital_status```se tratará de un problema de clasificaicón binaria. Mientras que si elegimos el estadío del tumor, sería un problema de clasificación multiclase.

# Datos de Expresión Génica

Vamos a explorar nuestros datos de Expresión Génica ```ExpGenKIRC3```. Observamos que se trata de un archivo ```RangedSummarizedExperiment```, para tratar este tipo de archivos podemos seguir la siguiente guía: https://www.bioconductor.org/packages/release/bioc/vignettes/SummarizedExperiment/inst/doc/SummarizedExperiment.html. 

## Introducción

La clase ```SummarizedExperiment``` se usa para llenar matrices rectangulares de resultados experimentales producidos normalmente en experimentos de secuenciación o microarrays. Cada objeto almacena observaciones de una o más muestras, junto con metadatos adicionales que describen obsevaciones (características) y muestras (fenotipos).

Un aspecto clave de la clase ```SummarizedExperiment``` es la coordinación de los metadatos y los ensayos cuando se realizan subagrupaciones o subconjuntos. Por ejemplo, si quieres excluir una muestra se puede hacer en los metadatos y en los ensayos en una única operación, lo que asegura que los metadatos y los datos observados permanezcan sincronizados.

## Anatomía de SummarizedExperiment

El paquete ```SummarizedExperiment``` contiene dos clases: ```SummarizedExperiment``` y ```RangedSummarizedExperiment```.

```SummarizedExperiment``` es un contenedor similar a una matriz donde las filas representan características de interés (por ejemplo: genes, transcritos, exones, etc.) y las columnas representan las muestras. Los objetos contienen uno o más ensayos, cada uno representado por un objeto matriz de número u otro modo. Las filas del objeto ```SummarizedExperiment``` representan características de interés. La información acerca de estas características está almacenada en un objeto Dataframe, accesible usando la función ```rowData()```. Cada fila del Dataframe aporta información de la característica en la fila correspondiente del objeto ```SummarizedExperiment```. Las columnas del Datafram representan diferentes atributos de las características de interés como IDs de genes o transcritos.

```RangedSummarizedExperiment``` es el "hijo" de la clase ```SummarizedExperiment```, lo que significaa que todos los métodos de ```SummarizedExperiment```también funcionan sobre ```RangedSummarizedExperiment```.

La diferencia fundamental entre las dos clases es que las filas de ```RangedSummarizedExperiment```representan rangos genómicos de interés en vez de un Dataframe de carcterísticas. Los rangos de ```RangedSummarizedExperiment```se describen en el objeto ```GRanges```o ```GRangesList```, accesible utilizando la función ```rowRanges()```.


## Assays

```{r}
library(SummarizedExperiment)
se <- ExpGenKIRC3
se
```

Para recuperar los datos a partir del experimento a partir de un objeto ```SummarizedExperiment``` se puede utilizar ```assays()```. Un objeto puede tener múltiples dataset de ensayos a los que se puede acceder usando el operador ```$```. En nuestro caso tenemos dos datasets: ```raw_count``` y ```scaled_estimate```. Partiremos desde el archivo ```raw_count``` para realizar nuestro análisis.

```{r}
assays(se)$raw_count[1:3,1:4]
```


```{r}
rowRanges(se)
```

## Columnas (datos de las muestras)

Se puede acceder a los metadatos que describen las muestras usando ```colData()``, y es un Dataframe que puede almacenar cualquier número de columna.

```{r echo=T, results='hide'}
colData(se)
```

Se puede acceder a estos metadatos usando ```$```, lo que hace más sencillo sustraer un objeto entero dado un fenotipo. Por ejemplo, podemos extraer todas las muestras que tengan una etiqueta para el estado vital:

```{r}
se[, se$vital_status == "Dead" | se$vital_status == "Alive"]
```

En este Dataframe, a pesar de ser del proyecto TCGA-KIRC, hay 606 muestras, cuando en el de datos clínicos había 537. Parece que todas las muestras de datos de Expresión génica tienen su etiqueta de ```vital_status``` correspondiente. Encontramos 202 muertos y 404 vivos.

Vamos a buscar Missing values para la etiqueta de Fase del tumor para lo cual utilizaremos el siguiente código:

```{r}
which(is.na(se$ajcc_pathologic_stage))
se$patient[c(128,190,460)]
```

Los códigos de los pacientes que no tienen esta etiqueta disponible son los mismos que no la tenían para los datos clínicos, lo cual tiene sentido.

## Preprocesado: Exploración, Control de Calidad y Normalización de datos TCGA

Seguiremos el Pipeline mostrado en: https://bioconductor.org/packages/release/bioc/vignettes/TCGAbiolinks/inst/doc/analysis.html#TCGAanalyze:_Analyze_data_from_TCGA

### Control de calidad

https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-020-3399-8

```{r}
KIRCnaseq_CorOutliers <- TCGAanalyze_Preprocessing(ExpGenKIRC3)
```

```{r eval=FALSE, out.width = "450px", fig.cap="Gráfica de correlaciones y Array-Array Intensity Correlation (AAIC)", include=TRUE}
knitr::include_graphics("figures/PreprocessingOutput.png")
```

```{r}
BiocManager::install(c("shiny", "FactoMineR", "factoextra", "som", "psych", "data.table", "ape", "corrplot", "limma", "DESeq2"))
library("shiny")
```

iSeqQC requires two files for the analysis. Both files should be ASCII formatted tab-delimited file only

#### Creando archivo 1

File 1- Sample phenotype data: First 4 columns should strictly match the names and order as mentioned below (names case-sensitive)
Sample names in first column 'samples' should match the names in counts matrix file
column 1: samples
column 2: shortnames
column 3: groups
column 4: include
column 5-11: any factors such as library method, protocol etc.

```{r}
QCinput1 <- data.frame(samples = ExpGenKIRC3$barcode, shortnames = ExpGenKIRC3$sample, groups = ExpGenKIRC3$vital_status, include = rep(TRUE, 606))
QCinput1[1:10,1:4]
```

```{r}
write.table(QCinput1, file = "QCinput1.txt" , append = FALSE,
            row.names = FALSE)
```


#### Creando archivo 2

```{r}
QCinput2 <- TCGAanalyze_Normalization(tabDF = ExpGenKIRC3, geneInfo =  geneInfo)
write.table(QCinput2, file = "QCinput2.txt")
```

#### Iniciar y utilizar el programa

```{r}
#setwd("D:/Users/Carmen/Documents/R/win-library/4.0/iSeqQC_shinyapp")
#runApp(appDir = getwd())
```

Resultado del programa: La mayoría de las gráficas no pueden apreciarse debido a una gran cantidad de muestras. Mostraremos una gráfica de la densidad de lecturas mapeadas por muestra.

![Gráfica de la densidad de lecturas mapeadas por muestra](figures/uUemKL.png)

### Normalización y Filtrado

#### Prefiltrado de la base de datos

La matriz de conteos presenta varias filas nulas o con pocos fragmentos por muestra/gen. Con el objetivo de disminuir el tamaño del objeto, optimizar el análisis, y reducir el tiempo de ejecución de las funciones, eliminaremos los valores de la matriz de conteos que no nos aporten información relevante sobre la expresión génica, es decir las filas de ```assay(se)``` que no tengan o tengan pocos conteos.

```{r}
#Número de filas que tiene el archivo assay(se)
nrow(assay(se))
```

```{r}
#subconjunto quedándonos con las filas con sumatorio de conteos mayores a 1 y guardado de este cambio en el objeto
keep <- rowSums(assay(se)) > 1
se <- se[keep,]
nrow(assay(se))
```

#### Normalización

```{r}
#Downstream análisis usando datos de expresión génica de muestras dde TCGA de IlluminaHiSeq_RNASeqV2 com extensión rsem.results

library(TCGAbiolinks)
dataNorm <- TCGAanalyze_Normalization(tabDF = se, geneInfo =  geneInfo)
```

```TCGAanalyze_Normalization``` nos ha devuelto el archivo ```dataNorm```, que se trata de una matriz bastante grande. Si lo observamos vemos que se trata de la matriz de conteos pero sin decimales.

```{r}
dataNorm[1:10,1:3]
```


Pasamos de tener un objeto con 19648 filas a un objeto con 19433 filas.

#### Transformación log2

Muchos métodos estadísticos de visualización y exploración de datos trabajan mejor con versiones de los datos de conteos que han sido transformados. La distribución de los datos de la matriz de conteos está bastante sesgada debido a que los genes con más conteos muestran diferencias más grandes entre muestras, es por ello que una transformación de los datos ayuda a normalizar la distribución. Estos datos podemos transformarlos con distintos métodos entre los que destacan VST, rlog o log2 pero, ¿qué transformación debemos escoger? En nuestro caso utilizaremos la transformación log2(x+1) que deja los valores menores de 1 como 0, ya que este tipo de valores suele ser ruido.

```{r}
dataNormt <- log2(dataNorm+1)
```


```{r}
dataNormt[1:10,1:3]
```

###  Exploración estadística de los datos

#### Distancias muestrales

Una primera aproximación para el análisis de RNA-seq es observar la similitud general entre muestras, para ello podemos utilizar la función ```dist()```de R, que nos permite calcular la distancia Euclidea entre muestras. Este abordaje lo realizaremos con los datos transformados para estar seguros que hay una contribución equivalente de todos los genes.

```{r eval=FALSE, include=FALSE}
sampleDists <- dist(dataNormt)
sampleDists
```


### Análisis de expresión diferencial (DEA)

Realizar DEA (*Differential expression analysis*) para identificar genes expresados diferencialmente (DEGs) utilizando la función ```TCGAanalyze_DEA```.

```TCGAAnalyze_DEA``` utiliza las siguiente funciones de R:

1. ```edgeR::DGEList``` que convierte la matriz de conteos en un objeto edgeR.
2. ```edgeR::estimateCommonDisp``` se le asigna a cada gen el mismo estimador de dispersión
3. ```edgeR::exactTest```realiza el test de comparación por parejas (*pair-wise test*) para la expresión diferenciaal entre dos grupos.
4. ```edgeR::topTags``` coge el resultado de ```exactTest()```, ajusta los p-valores crudos utilizando la corrección FDR y devuelve los genes más diferencialmente expresados.

Después, filtramos el resultado de dataDEGs con ```abs(LogFC) >= 1```, y utilizamos la función ```TCGAanalyze_levelTab```para crear una tabla con DEGs (genes diferencialmente expresados), log Fol Change (FC), false discovery rate (FDR), el nivel de expresión génica para las muestras de la condición 1 y la condición 2 y el valor Delta.


#### Filtrado 

Queremos una variabilidad mayor del percentil 75 y hacer el experimento con estos genes


```{r}
#quantile filter of genes
dim(dataNorm)
dataFilt2 <- TCGAanalyze_Filtering(tabDF = dataNorm, method = "quantile", qnt.cut = 0.75)
dim(dataFilt2)
```

El archivo resultante ```dataFilt``` se ha quedado en un tamaño de 23 Mb (2967582 elementos), mientras que el archivo con los datos normalizados pesaba 91.8 Mb.

```{r}
dataFilt2[1:10, 1:3]
```


#### Separación de muestras

Si queremos seguir con el DEA tendremos que separar las muestras según nuestra variable de interés. En nuestro caso, la variable de interés es vital_status.

```{r}
samplesD <- subset(se$barcode, se$vital_status == "Dead")
samplesA <- subset(se$barcode, se$vital_status == "Alive")
```

#### Diff.expr.analysis (DEA)

Vamos a tener en cuenta qué significa cada uno de los parámetros que se incluyen como argumentos en la función. El ```log2FoldChange``` es el efecto de muestra estimado, es decir, cuánto parece haber cambiado la expresión génica debido al grupo al que pertenece la muestra o tipo de infiltración. Este valor tiene una incertidumbre que se ve reflejada en la columna lfcSE.

```{r}
# Diff.expr.analysis (DEA)
dataDEGs <- TCGAanalyze_DEA(mat1 = dataFilt2[,samplesD],
                            mat2 = dataFilt2[,samplesA],
                            Cond1type = "Dead",
                            Cond2type = "Alive",
                            fdr.cut = 0.10,
                            logFC.cut = 0.4,
                            method = "glmLRT")
```

Tras esto, podemos crear la tabla resumen:

```{r}
dataDEGsFiltLevel <- TCGAanalyze_LevelTab(dataDEGs, "Dead", "Alive", dataFilt2[,samplesD], dataFilt2[,samplesA])
```
...
```{r}
dim(dataDEGsFiltLevel)
dataDEGsFiltLevel[1:10,1:6]
```

**PCA plot**

```{r}
pca <- TCGAvisualize_PCA(dataFilt2, dataDEGsFiltLevel, ntopgenes = 200, samplesA, samplesD)
```

Aunque en la gráfica ponga que se trata de genes diferencialmente expresados entre muestras tumorales y normales, se trata de muestras de pacientes fallecidos (rojo) y vivos (azul).

# Expresión proteica

De acuerdo con la información mostrada en: https://www.bioconductor.org/packages/devel/bioc/vignettes/TCGAbiolinks/inst/doc/download_prepare.html y http://www.linkedomics.org/data_download/TCGA-KIRC/, los datos de expresión proteica que hemos descargado del archivo legacy se trata de los resultados de un experimento *Reverse Phase Protein Array* (RPPA).

Encontramos información sobre este tipo de técnica en el siguiente artículo:

Boellner S., Becker K.-F. Reverse Phase Protein Arrays—Quantitative Assessment of Multiple Biomarkers in Biopsies for Clinical Use. Microarrays. 2015;4:98–114. doi: 10.3390/microarrays4020098

La técnica RPPA es una tecnología utilizada para medir cuantitativamente cientos de proteínas señal en muestras biológicas y clínicas. Este formato en forma de array permite la cuantificación de proteínas o fosfoproteínas en muestras múltiples bajo las mismas condiciones experimentales de manera simultánea. Además es posible utilizarla para obtener los perfiles de transducción de señales de pequeños grupos de células en cultivo o células aisladas de biopsias humanas incluídos tejidos fijados con formaldehído o embebidos en parafina. En cuanto a **ventajas** sobre otras técnicas proteomicas como la espectroscopía de masas encontramos que la **preparación de muestras es mucho más sencilla** y que tiene una **buena detección de proteínas de señalización poco abundantes. 

```{r eval=TRUE, out.width = "300px", include = FALSE, fig.cap="Presentación esquemática de un array de proteínas en fase reversa (RPPA), donde la proteína A es nuestra proteína de interés", include=TRUE}
knitr::include_graphics("figures/RPPA.png")
```
## Introducción a RPPA

source: https://bioinformatics.mdanderson.org/public-software/tcpa/ 

**What is RPPA?**

Reverse phase protein array (RPPA) is a high-throughput antibody-based technique with the procedures similar to that of Western blots. Proteins are extracted from tumor tissue or cultured cells, denatured by SDS, printed on nitrocellulose-coated slides followed by antibody probe. Our RPPA platform currently allows for the analysis of >1000 samples using at least 130 different antibodies.

**What are the advantages of RPPA?**

* Inexpensive, high-throughput method utilizing automation for increased quality and reliability
* Sample preparation requirements are similar to that of Western blots
* Complete assay requires only 40 microliters of each sample for 150 antibodies
* Robust quantification due to serial dilution of samples

**How are the RPPA data processed?**

Level 1 data

Cellular proteins are first denatured by 1% SDS (with beta mercaptoethanol) and diluted in five 2-fold dilutions in dilution buffer (lysis buffer containing 1% SDS). Serial diluted lysates are arrayed on nitrocellulose-coated slides (Grace Biolabs) by the Aushon 2470 Arrayer  and probed with validated antibodies. Signals are amplified by TSA and captured by DAB colorimetric reaction. The slides are then scanned, analyzed and quantified by ArrayPro Analyzer  to generate spot intensity.

Level 2 data

Based on Level 1 data, each dilution curve of spot intensities is fitted using the monotone increasing B-spline model in the SuperCurve R package. This fits a single curve using all the samples on a slide with the signal intensity as the response variable and the dilution steps as independent variables. The fitted curve is plotted with the signal intensities on the y-axis and the log2-concentration of proteins on the x-axis for diagnostic purposes.

Level 3 data

Based on Level 2 data, the data normalization is processed as follows:

1. Calculate the median for each protein across all the samples.
2. Subtract the median (from step 1) from values within each protein.
3. Calculate the median for each sample across all proteins.
4. Subtract the median (from step 3) from values within each sample.

**How do we quantify protein expression and modification?**

We use the approach of “SuperCurve Fitting” developed by the Department of Bioinformatics and Computational Biology at MD Anderson Cancer Center to quantify protein expression and modification. Briefly, a “standard curve” is constructed from 5808 spots on each slide (one slide probed for one antibody). These spots include 5 serial dilutions of each sample plus 528 QC spots of standard lysates at different concentrations. Relative levels of protein expression and modification for each sample are determined by interpolation of each dilution curve to the “standard curve” (supercurve) of the slide (antibody).

## Procedimiento de RPPA

Para utilizar RPPA en la rutina clínica, esta técnica tiene que ser reporducible y fácil de adaptar a pruebas de alto rendimiento. Entre los pasos para la realización de este microarray de proteínas enumeramos:

1- Preparación de muestras
2- Validación de anticuerpos
3- Spotting
4- Detección de señal
5- Análisis de datos

```{r eval=TRUE, out.width = "400px", include = FALSE, fig.cap="Workflow de los estudios de RPPA", include=TRUE}
knitr::include_graphics("figures/RPPAworkflow.png")
```

En esta técnica es importante utilizar anticuerpos específicos que se unan a la proteína de interés obteniendo una única banda a un peso molecular correcto (análisis de anticuerpos mediante Western Blot). Los anticuerpos se comprueban primero con un WB con lisados de 10 o más líneas celulares y después para lisados de nuestra muestra de interés.

En cuanto a la fase de Spotting, nuestra placa está recubierta de nitrocelulosa y tiene un tamaño de 7 cm x 2 cm. Para los estudios tipo RPPA se necesitan volúmenes muy pequeños de muestra (1 nL de una disolución 2 ng/nL). Tras inmovilizar las proteínas en la cuadrícula, estas son detectadas con anticuerpos cuya especificidad por el antigeno ha sido validada. La señal puede ser de muchos tipos (tinciones cercanas al infrarrojo, chivatos cromogénicos, quimioluminiscencia...). Se utiliza el softwaere MicroVigene array software para tratar las imagenes obtenidas. Dado que se han hecho diluciones seriales a la hora de realizar el spotting, podemos cuantificar los niveles de proteína para cada muestra.

## Análisis

```{r echo=T, results='hide'}
ExprProtKIRC
```

```{r echo=T, results='hide'}
str(ExprProtKIRC)
```

```{r echo=T, results='hide'}
summary(ExprProtKIRC)
```


Vamos a comprobar si existen duplicados dentro del dataset:

```{r}
nrow(ExprProtKIRC[duplicated(ExprProtKIRC), ])
```

Y si hay misissing values:

```{r, results= "hide"}
sapply(ExprProtKIRC, function(x) sum(is.na(x)))
```

Nos aparecen los Nas por columna. Vemos que casi todas las columnas tienen unos 41 NAs. Por lo que estas filas de genes con NAs tenemos que omitirlas. Utilizaremos ```na.omit()``` que devuelve el objeto con los casos incompletos retirados.

```{r}
datos <- na.omit(ExprProtKIRC)
```

Ahora tenemos 177 genes.

Por otro lado, tenemos que fijarnos también en las muestras y compararlas con los datos de expresión génica. Guardamos el nombre de las columnas de ```ExprProtKIRC``` en ```ExprProtColAn```, por si acaso necesitamos este vector en algún momento.

```{r}
ExprProtColAn <- colnames(ExprProtKIRC)[2:479]
```

Vamos a cambiar el nombre de las columnas de ```ExprProtKIRC``` que son del estilo ```"TCGA-B4-5835-01A-13-1742-20"``` por el nombre acortado de las muestras. Así podremos coger justo las muestras que coincidan entre ```ExprProtKIRC``` y ```ExpGenKIRC3$sample```. Para eso necesitaremos un bucle ```for```. Las columnas renombradas se guardarán en el vector ```muestras```.

```{r}
muestras <- c()
for (j in colnames(ExprProtKIRC)[2:479]){
  muestras <- c(muestras, sub("(.*-.*-.*-.*)-.*-.*-.*", "\\1", j))
}
muestras
```

Ahora vamos a recuperar los índices en el vector de Expresión Génica ```se$sample``` de los elementos del vector ```muestras```que coincidan, y guardamos estos índices en el vector ```index```.

```{r}
index <- c()
for (i in muestras){
  index <- c(index, which(se$sample %in% i))
}
str(index)
```

Vemos que el vector index tiene 474 elementos, sin embargo el vector muestras tenía 478 elementos, por lo que 4 muestras del dataset de Expresión Proteica no se encuentran en el dataset de Expresión Génica ¿Qué muestras de ```ExprProtKIRC``` no se encuentran en ```ExpGenKIRC3```?

```{r}
which(match(muestras, se$sample, nomatch = "0") %in% 0)
```

Ahora tenemos que quitar de los datos de expresión génica los que no se encuentran en los datos de expresión proteica y viceversa. De nuestro vector ```muestras```queremos quitar los elementos que se encuentran en los índices 74, 237, 330 y 462.

```{r}
ncol(datos)
k <- sort(c(74,237,330,462), decreasing = TRUE)
for (k in k){
  datos[k] <- NULL
}
ncol(datos)
```

```{r}
length(muestras)
k <- c(74,237,330,462)
muestras <- muestras[-k] 
length(muestras)
```

Ahora podemos conseguir las etiquetas de ```vital_status``` para los datos de expresión Proteica.

```{r}
ExpProtLabels <- c() 
for (i in index){
  ExpProtLabels <- c(ExpProtLabels, se$vital_status[i])
}
```

Ahora vamos a quitar las muestras de Expresión Génica que no estén en Expresión Proteica


```{r}
index2 <- sort(which(match(se$sample, muestras,  nomatch = "0") %in% 0), decreasing = TRUE)
ncol(dataNorm)
for (k in index2){
  dataNorm <- dataNorm[, -k] 
}

ncol(dataNorm)
```

```{r}
index3 <- sort(which(match(se$sample, muestras,  nomatch = "0") %in% 0), decreasing = TRUE)
ncol(dataNormt)
for (k in index3){
  dataNormt <- dataNormt[, -k]
}
ncol(dataNormt)
```

Vemos que ahora tanto el archivo de Expresión proteica ```datos``` como el de los datos de Expresión Génica normalizados ```dataNorm``` y transformados ```dataNormt```, tienen todos 474 muestras.

Ahora conseguimos las etiquetas de ```vital_status``` para los datos de expresión génica.

```{r}
'%nin%' <- Negate('%in%')
index3 <- sort(which(match(se$barcode, colnames(dataNorm),  nomatch = "0") %nin% 0), decreasing = TRUE)
ExpGenLabels <- c() 
for (i in index3){
  ExpGenLabels <- c(ExpGenLabels, se$vital_status[i])
}
```

Con ```dim(datos)``` vemos que tenemos un archivo de expresión proteica con 475 observaciones y 177 proteínas, pero ¿cuántas de esas 177 proteínas se corresponden con los 238 genes que hemos obtenido en el análisis de expresión diferencial de los datos de expresión génica? 

```{r}
dim(datos)
```


# Análisis Epigénetico

## Introducción

La metilación  del ADN es un componente importante en numerososo procesos celulares como en el desarrollo embrionario, huella genética, inactivación del cromosoma X y la conservación de la estabilidad cromosómica (Phillips 2008).

En mamíferos la metilación del ADN es escasa pero se extiende por todo el genoma distribuyendose en secuencias CpG (CGIs) que son secuencias pequeñas de ADN interespaciadas que  están enriquecidas en GC. Estas islas se encuentran normalmente en sitios de iniciación dde la transcripción y su metilación conlleva al silenciamiento de los genes.

Por lo que, la investigación de la metilación del ADN es crucial para entender las redes de regulación génica en cáncer dado que la metilación de ADN reprime la transcripción. La detección de DMR (*Differentially Methylation Region*), regiones diferencialmente metiladas, pueden ayudarnos a investigar mecanismos de regulación génica.

En esta sección se describe el análisis de metilación del ADN utilizando el paquete de Bioconductor TCGAbiolinks.

Ver más: https://www.bioconductor.org/packages/release/workflows/vignettes/TCGAWorkflow/inst/doc/TCGAWorkflow.html#epigenetic_analysis

## Obtención de los datos

Mirar: https://www.researchgate.net/post/How_to_handle_big_data_sets_10GB_in_R_Bioconductor_packages. Es imposible conseguir el dataset entero porque no tenemos tanta RAM. Utilizaremos un Dataset más pequeño. Se hará uso de la función ```matchedMetExp()``` que obtiene los barcodes de muestras con datos tanto de metilación como de expresión génica para un proyecto de TCGA. A partir de aquí el código estará comentado ya que, a pesar de que hemos conseguido obtener el objeto de metilación en R, a la hora de realizar el archivo Markdown nos vuelve a dar problemas de RAM.


```{r}
#setwd("D:/datos")
#samples <- matchedMetExp("TCGA-KIRC", n = 166)
#query <- GDCquery(project = c("TCGA-KIRC"),
                  #data.category = "DNA methylation",
                  #platform = "Illumina Human Methylation 450",
                  #legacy = TRUE, 
                  #barcode = samples)
#GDCdownload(query)
#met <- GDCprepare(query, save = FALSE)
```

Hemos puesto un argumento de ```n=166```, que es el límite para que nuestro ordenador pueda crear el objeto ```met```.

## Preprocesado 

Los datos obtenidos necesitan un preprocesado. Los datos de metilación de la plataforma 450K tienen tres tipos de sondas cg (CpG loci), ch (no CpG loci) y rs (ensayo SNP). El último tipo puede usarse para identificación de las muestras y debe quitarse del análisis de metilación diferencial según el manual de Illumina. Por lo que tendremos que quitar las sondas rs. También tendremos que quitar las sondas de los cromosomas X e Y para eliminar errores debidos a la presencia de una proporción de hombres y mujeres diferente. El último paso de preprocesado es quitar las sondas con al menos un valor de NA.

Tras todo este preoprocesado utilizaremos la función ```TCGAvisualize_meanMethylation```, que nos permite mirar la media de la metilación del ADN de cada paciente para cada grupo.

Primero vamos a echarle un vistazo a nuestro archivo ```met``` que es un objeto tipo ```RangedSummarizeExperiment```.

```{r}
#met
```

Podemos sacar la tabla con datos con ```assay()```.

```{r}
#assay(met)[1:10,1:2]
```


```{r}
#met2 <- met
#nrow(assay(met))
```

### Quitar las sondas SNP 

```{r}
#SNPprobes <- grep("rs", rownames(met))
#length(SNPprobes)
```

```{r}
#dim(met2)
#k <- sort(SNPprobes, decreasing = TRUE)
#for (k in k){
  #met2 <- met2[-k,]
#}
#dim(met2)
```

### Quitar sondas de los cromosomas X e Y

```{r}
#met2 <- subset(met2, subset = !as.character(seqnames(met2)) %in% c("chrNA", "chrX", "chrY"))
#dim(met2)
```

### Quitar sondas con al menos un missing value

```{r}
#met2 <- subset(met2, subset = (rowSums(is.na(assay(met2)))==0))
#dim(met2)
```

## Explorando archivos

Ya hemos realizado el preprocesado de los datos de metilación, quitando las sondas de SNPs, las de cromosomas sexuales y las que tienen missing values.

Tras este preprocesado y utilizando la función ```TCGAvisualizr_meanMethylation``` podemos observar la metilación del ADN media para cada paciente en cada grupo. Este recibe como argumento un objeto ```SummarizedExperiment```con los datos de metilación del ADN y los argumentos ```groupCol``` y ```subgroupCol```que deben ser las dos columnas de la matriz de información de muestras del objeto ```SummarizedExperiment```(se accede a esto mediante la función ```colData```).

```{r}
#df <- data.frame("Sample.mean" = colMeans(assay(met2), na.rm = TRUE), "groups" = met2$vital_status)
#library(ggpubr)
#ggpubr::ggboxplot(df,
                  #y = "Sample.mean",
                  #x = "groups",
                  #color = "groups",
                  #add = "jitter",
                  #ylab = expression(paste("Mean DNA methylation (", beta, "-values)")),
                  #xlab = "") + 
#stat_compare_means() 
```
```{r echo=FALSE, out.width = "450px", fig.cap="Gráfica la media de la metilación del ADN para cada muestra del grupo de vivos (n = 96) y muertos (n = 54)"}
knitr::include_graphics("figures/MethylationMeanGroups.png")
```

Realizando el test de Wilcoxon, una prueba no paramétrica que compara el rango medio de dos muestras y determina si existen diferencias entre ellas, obtenemos un p = 0.018, que es menor de 0.05, por lo que rechazamos la hipótesis nula a favor de la alternativa de que las medias de metilación son distintas entre grupos.

### Buscando sitios CpG diferencialmente metilados

El siguiente paso es definir sitios diferencialmente metilados entre ds grupos. Este puede realizarse utilizando la función ```TCGAnalyze_DMC```. Los datos de metilación de ADN (nivel 3) están presentados en forma de valores beta que usan una escala que va desde 0 (sondas completamente sin metilar) hasta 1 (sondas completamente metiladas).

Para encontrar estos sitios diferencialmente metilados, primero, la función calcula la diferencia entre la media de la metilación del ADN (media de valores beta) de cada grupo para cada sonda. Segundo, se comprueba la expresión diferencial entre dos grupos utilizando el test de Wilcoxon ajustado por ele método de Benjamini-Hochberg. Se determinaron los argumentos de ```TCGAanalyze_DMR``` para requerir una diferencia mínima absoluta de valores beta de 0.15 y un p-valor ajustado menor de 0.05.

Tras estos test, se crea una gráfica tipo volcán (eje x: diferencia de medias de metilación de ADN, eje y: significancia estadística) para ayudar a los usuarios a identificar sitios CpG diferencialmente metilados y devuelven un objeto con los resultados en los rowRanges.

```{r}
#------- Searching for differentially methylated CpG sites     ----------
#dmc <- TCGAanalyze_DMC(met2,
                       #groupCol = "vital_status", # a column in the colData matrix
                       #group1 = "Dead", # a type of the disease type column
                       #group2 = "Alive", # a type of the disease column
                       #p.cut = 0.05,
                       #diffmean.cut = 0.15,
                       #save = FALSE,
                       #legend = "State",
                       #plot.filename = "survival_metvolcano.png",
                       #cores = 1 # if set to 1 there will be a progress bar
#)
```

Este código ha tardado en correr 5 h. La figura de abajo muestra la gráfica de tipo volcán creada. Esta gráfica ayuda al usuario a seleccionar umbrales relevantes cuando buscamos regiones diferencialmente metiladas.

```{r echo=FALSE, out.width = "450px", fig.cap="Volcano plot: Buscando sitios CpG diferencialmente metilados (eje x: diferencia de metilación de ADN media, eje y: significación estadística)"}
knitr::include_graphics("figures/survival_metvolcano.png")
```

Podemos obtener las sondas que están hipermetiladas o hipometiladas

```{r}
# get the probes that are Hypermethylated or Hypomethylated
# met is the same object of the section 'DNA methylation analysis'
#status.col <- "status"
#probes <- rownames(dmc)[grep("hypo|hyper",dmc$status,ignore.case = TRUE)]
#sig.met <- met2[probes,]
#probes

#Results
#[1] "cg01530101" "cg03257743" "cg05003554" "cg06822943" "cg06879394" "cg08960448" "cg09047734"
#[8] "cg09827761" "cg13608171" "cg18157012" "cg18582260" "cg19206146" "cg19473623" "cg20321706"
#[15] "cg21538684" "cg22605290" "cg23709902" "cg25542878" "cg26286961" "cg27088072"
```
Tenemos muy pocas sondas porque ya empezamos con menos muestras que en las otras ómicas, además hemos sido demasiado restrictivos a la hora de hacer el análisis diferencial de metilación.

Para visualizar los niveles de metilación de estas sondas a lo largo de las muestras, utilizamos mapas de calor que pueden generarse con el paquete de Bioconductor ```complexHeatmap``` (instalación: ```BiocManager::install("ComplexHeatmap")```). Para crear un mapa de calor con el paquete ```complexHeatmap```, el usuario debe proporcionar al menos una matriz con los niveles de metilación de ADN. También se pueden añadir capas de anotación que se pueden colocar abajo, arriba, a la izquierda o a la derecha del heatmap para tener la descripción proporcionada en los metadatos (```ClinicKIRC2```).

```{r}
#library(ComplexHeatmap)
#clinical.order <- ClinicKIRC2[match(substr(colnames(sig.met),1,12),ClinicKIRC2$bcr_patient_barcode),]
#ta = HeatmapAnnotation(df = clinical.order[, c("vital_status", "gender", #"stage_event_pathologic_stage")],
                       #col = list(
                         #vital_status = c("Alive" = "grey", "Dead" = "black")
                       #))
#ra = rowAnnotation(
  #df = dmc[probes, status.col],
  #col = list(
    #"status.survival" =
      #c("Hypomethylated" = "orange",
        #"Hypermethylated" = "darkgreen")
  #),
  #width = unit(1, "cm")
#)

#heatmap  <- Heatmap(assay(sig.met),
                    #name = "DNA methylation",
                    #col = matlab::jet.colors(200),
                    #show_row_names = TRUE,
                    #cluster_rows = TRUE,
                    #cluster_columns = TRUE,
                    #show_column_names = FALSE,
                    #bottom_annotation = ta,
                    #column_title = "DNA Methylation") 
#png("heatmap.png",width = 600, height = 400)
#draw(heatmap, annotation_legend_side =  "bottom")
#dev.off()
```
```{r echo=FALSE, out.width = "450px", fig.cap="Heatmap: Se han agrupado tanto las muestras como las sondas en clusters. Se muestran las sondas hiper o hipometiladas para cada muestra de nuestros datos epigenéticos)"}
knitr::include_graphics("figures/heatmap.png")
```
# Igualando los datos de Expresión Génica, proteica y metilación

Ya teníamos igualados los datos de Expresión Génica y proteica y teniamos una n total de 474.

```{r}
#dim(datos)
```
```{r}
#dim(dataNorm)
```
Sin embargo, de datos de metilación al final solo teniamos una n = 150

```{r}
#dim(met2)
```
Las muestras en el archivo de metilación tienen nombres tipo ```TCGA-G6-A8L8-01A-21D-A36Y-05``` mientras que en Expresión proteica ```TCGA-B4-5835-01A-13-1742-20``` y en Expresión génica ```TCGA-B0-5694-01A-11R-1541-07```.

Vamos a cambiar el nombre de las columnas de ExprProtKIRC que son del estilo "TCGA-B4-5835-01A-13-1742-20" por el nombre acortado de las muestras. Así podremos coger justo las muestras que coincidan entre ```datos``` y ```met2$sample```. Para eso necesitaremos un bucle for. Las columnas renombradas se guardarán en el vector muestras.


```{r}
#muestras2 <- c()
#for (j in colnames(datos)[2:475]){
#muestras2 <- c(muestras2, sub("(.*-.*-.*-.*)-.*-.*-.*", "\\1", j))
#}
#length(muestras2)
```

Ahora vamos a recuperar los índices en el vector de metilación ```met2$sample``` de los elementos del vector muestras2 que coincidan, y guardamos estos índices en el vector index4.

```{r}
#index4 <- c()
#for (i in muestras2){
#index4 <- c(index4, which(met2$sample %in% i))
#}
#str(index4)
```
Vemos que el vector index tiene 131 elementos, sin embargo el vector muestras2 tenía 474 elementos, por lo que 343 muestras del dataset de Expresión Proteica no se encuentran en el dataset de metilación ¿Qué muestras de Expresión Proteica no se encuentran en el de metilación?

```{r}
#index5 <- which(match(muestras2, met2$sample, nomatch = "0") %in% 0)
#length(index5)
```

Ahora tenemos que quitar de los datos de metilación los que no se encuentran en los datos de expresión proteica y viceversa. De nuestro vector muestras2 queremos quitar los elementos que se encuentran en los índices de index5. 

```{r}
#k <- sort(index5, decreasing = TRUE)
#datos2 <- datos
#for (k in k){
#datos2[k] <- NULL
#}
#ncol(datos2)
```
Ahora podemos conseguir las etiquetas de vital_status para los datos de expresión Proteica.

```{r}
#ExpProtLabels2 <- c()
#for (i in index4){
#ExpProtLabels2 <- c(ExpProtLabels2, met2$vital_status[i])
#}
```

Ahora tenemos una n=131 en datos de Expresión proteica. Ahora vamos a quitar las muestras de metilación     que no estén en Expresión Proteica.

```{r}
#index6 <- sort(which(match(met2$sample, muestras2, nomatch = "0") %in% 0), decreasing = TRUE)
#ncol(met2)
```
El vector ```index6``` tiene una longitud de 19 elementos porque ```150 - 131 = 19```. Las muestras iniciales que teníamos de metilación restándoles las muestras que tenemos al final en común entre las dos ómicas que estamos comparando.

```{r}
#met3 <- met2
#for (k in index6){
#met3 <- met3[, -k]
#}
#ncol(met3)
```
Vemos que ahora tanto el archivo de Expresión proteica datos como el de los datos de metilación tienen todos 131 muestras. Vamos ahora a igualar el archivo de Expresión génica con el de metilación.

```{r}
#muestras3 <- c()
#for (j in colnames(dataNorm)){
#muestras3 <- c(muestras3, sub("(.*-.*-.*-.*)-.*-.*-.*", "\\1", j))
#}
#length(muestras3)
```

```{r}
#index7 <- c()
#for (i in muestras3){
#index7 <- c(index7, which(met3$sample %in% i))
#}
#length(index7)
```
met3$sample tiene los elementos 82 y 83 repetidos, son las mismas muestras. Por lo que en realidad 

```{r}
#index8 <- which(match(muestras3, met3$sample, nomatch = "0") %in% 0)
#length(index8)
```

```{r}
#k <- sort(index8, decreasing = TRUE)
#dataNorm2 <- dataNorm
#dataNormt2 <- dataNormt
#for (k in k){
#dataNorm2 <- dataNorm2[, -k]
#dataNormt2 <- dataNormt2[, -k]
#}
#ncol(dataNorm2)
#ncol(dataNormt2)
```

Ahora podemos conseguir las etiquetas de vital_status para los datos de expresión génica.

```{r}
#ExpProtLabels3 <- c()
#for (i in index7){
#ExpProtLabels3 <- c(ExpProtLabels3, met3$vital_status[i])
#}
```